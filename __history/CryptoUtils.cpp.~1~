// CryptoUtils.cpp
#include "CryptoUtils.h"

std::string BytesToBase64(const std::vector<BYTE>& data) {
    DWORD requiredSize = 0;
    if (!CryptBinaryToStringA(data.data(), data.size(), CRYPT_STRING_BASE64 | CRYPT_STRING_NOCRLF, NULL, &requiredSize)) {
        throw std::runtime_error("CryptBinaryToStringA не вдалося визначити розмір");
    }

    std::string base64Str(requiredSize, '\0');
    if (!CryptBinaryToStringA(data.data(), data.size(), CRYPT_STRING_BASE64 | CRYPT_STRING_NOCRLF, &base64Str[0], &requiredSize)) {
        throw std::runtime_error("CryptBinaryToStringA не вдалося конвертувати дані");
    }

    // Видалення додаткового нульового символу
    if (!base64Str.empty() && base64Str.back() == '\0') {
        base64Str.pop_back();
    }

    return base64Str;
}

std::vector<BYTE> Base64ToBytes(const std::string& base64Str) {
    DWORD binarySize = 0;
    if (!CryptStringToBinaryA(base64Str.c_str(), base64Str.length(), CRYPT_STRING_BASE64, NULL, &binarySize, NULL, NULL)) {
        throw std::runtime_error("CryptStringToBinaryA не вдалося визначити розмір");
    }

    std::vector<BYTE> binaryData(binarySize);
    if (!CryptStringToBinaryA(base64Str.c_str(), base64Str.length(), CRYPT_STRING_BASE64, binaryData.data(), &binarySize, NULL, NULL)) {
        throw std::runtime_error("CryptStringToBinaryA не вдалося конвертувати дані");
    }

    return binaryData;
}

